(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "../pkg/dicomrle_wasm.js":
/*!*******************************!*\
  !*** ../pkg/dicomrle_wasm.js ***!
  \*******************************/
/*! exports provided: get_encoded_buffer, get_decoded_buffer, decode, initialize, __wbg_new_59cb74e423758ede, __wbg_stack_558ba5917b466edd, __wbg_error_4bb6c2a97407129a, __wbindgen_object_drop_ref */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dicomrle_wasm_bg.wasm */ \"../pkg/dicomrle_wasm_bg.wasm\");\n/* harmony import */ var _dicomrle_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dicomrle_wasm_bg.js */ \"../pkg/dicomrle_wasm_bg.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"get_encoded_buffer\", function() { return _dicomrle_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"get_encoded_buffer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"get_decoded_buffer\", function() { return _dicomrle_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"get_decoded_buffer\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"decode\", function() { return _dicomrle_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"decode\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"initialize\", function() { return _dicomrle_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"initialize\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_59cb74e423758ede\", function() { return _dicomrle_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_new_59cb74e423758ede\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_stack_558ba5917b466edd\", function() { return _dicomrle_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_stack_558ba5917b466edd\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbg_error_4bb6c2a97407129a\", function() { return _dicomrle_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbg_error_4bb6c2a97407129a\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_drop_ref\", function() { return _dicomrle_wasm_bg_js__WEBPACK_IMPORTED_MODULE_1__[\"__wbindgen_object_drop_ref\"]; });\n\n\n\n\n//# sourceURL=webpack:///../pkg/dicomrle_wasm.js?");

/***/ }),

/***/ "../pkg/dicomrle_wasm_bg.js":
/*!**********************************!*\
  !*** ../pkg/dicomrle_wasm_bg.js ***!
  \**********************************/
/*! exports provided: get_encoded_buffer, get_decoded_buffer, decode, initialize, __wbg_new_59cb74e423758ede, __wbg_stack_558ba5917b466edd, __wbg_error_4bb6c2a97407129a, __wbindgen_object_drop_ref */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get_encoded_buffer\", function() { return get_encoded_buffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get_decoded_buffer\", function() { return get_decoded_buffer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decode\", function() { return decode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initialize\", function() { return initialize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_new_59cb74e423758ede\", function() { return __wbg_new_59cb74e423758ede; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_stack_558ba5917b466edd\", function() { return __wbg_stack_558ba5917b466edd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbg_error_4bb6c2a97407129a\", function() { return __wbg_error_4bb6c2a97407129a; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"__wbindgen_object_drop_ref\", function() { return __wbindgen_object_drop_ref; });\n/* harmony import */ var _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dicomrle_wasm_bg.wasm */ \"../pkg/dicomrle_wasm_bg.wasm\");\n\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n/**\n* @param {number} encoded_size\n* @returns {number}\n*/\nfunction get_encoded_buffer(encoded_size) {\n    var ret = _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"get_encoded_buffer\"](encoded_size);\n    return ret;\n}\n\n/**\n* @param {number} encoded_size\n* @returns {number}\n*/\nfunction get_decoded_buffer(encoded_size) {\n    var ret = _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"get_decoded_buffer\"](encoded_size);\n    return ret;\n}\n\n/**\n*/\nfunction decode() {\n    _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"decode\"]();\n}\n\n/**\n*/\nfunction initialize() {\n    _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"initialize\"]();\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetUint8Memory0 = new Uint8Array(_dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst lTextEncoder = typeof TextEncoder === 'undefined' ? (0, module.require)('util').TextEncoder : TextEncoder;\n\nlet cachedTextEncoder = new lTextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer) {\n        cachegetInt32Memory0 = new Int32Array(_dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"memory\"].buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nconst __wbg_new_59cb74e423758ede = function() {\n    var ret = new Error();\n    return addHeapObject(ret);\n};\n\nconst __wbg_stack_558ba5917b466edd = function(arg0, arg1) {\n    var ret = getObject(arg1).stack;\n    var ptr0 = passStringToWasm0(ret, _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_malloc\"], _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_realloc\"]);\n    var len0 = WASM_VECTOR_LEN;\n    getInt32Memory0()[arg0 / 4 + 1] = len0;\n    getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n};\n\nconst __wbg_error_4bb6c2a97407129a = function(arg0, arg1) {\n    try {\n        console.error(getStringFromWasm0(arg0, arg1));\n    } finally {\n        _dicomrle_wasm_bg_wasm__WEBPACK_IMPORTED_MODULE_0__[\"__wbindgen_free\"](arg0, arg1);\n    }\n};\n\nconst __wbindgen_object_drop_ref = function(arg0) {\n    takeObject(arg0);\n};\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../wwww/node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///../pkg/dicomrle_wasm_bg.js?");

/***/ }),

/***/ "../pkg/dicomrle_wasm_bg.wasm":
/*!************************************!*\
  !*** ../pkg/dicomrle_wasm_bg.wasm ***!
  \************************************/
/*! exports provided: memory, get_encoded_buffer, get_decoded_buffer, decode, initialize, __wbindgen_free, __wbindgen_malloc, __wbindgen_realloc */
/***/ (function(module, exports, __webpack_require__) {

eval("\"use strict\";\n// Instantiate WebAssembly module\nvar wasmExports = __webpack_require__.w[module.i];\n__webpack_require__.r(exports);\n// export exports from WebAssembly module\nfor(var name in wasmExports) if(name != \"__webpack_init__\") exports[name] = wasmExports[name];\n// exec imports from WebAssembly module (for esm order)\n/* harmony import */ var m0 = __webpack_require__(/*! ./dicomrle_wasm_bg.js */ \"../pkg/dicomrle_wasm_bg.js\");\n\n\n// exec wasm module\nwasmExports[\"__webpack_init__\"]()\n\n//# sourceURL=webpack:///../pkg/dicomrle_wasm_bg.wasm?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var dicomrle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dicomrle */ \"../pkg/dicomrle_wasm.js\");\n/* harmony import */ var dicomrle_dicomrle_wasm_bg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dicomrle/dicomrle_wasm_bg */ \"../pkg/dicomrle_wasm_bg.wasm\");\n\n\n\ndicomrle__WEBPACK_IMPORTED_MODULE_0__[\"initialize\"]();\n\n  let decoder = undefined;\n  let encoder = undefined;\n  let decoderjs = undefined;\n  let encoderjs = undefined;\n  let decoderwasm = undefined;\n  let encoderwasm = undefined;\n  let encodedBitStream = undefined;\n\n  // upon loading a decoded bitstream, set to the decoded data so it can be reencoded\n  // as part of the lossy encoding functionality.  NOTE - is not changed after load  \n  let uncompressedImageFrame = undefined;\n  let fullEncodedBitStream = undefined; \n\n  let frameInfo = undefined;\n  let compressionRatio = 0;\n  let minMax = undefined;\n  let progressionOrder = undefined;\n  let decodeLevel = 0;\n  let decodeLayer = 0;\n  let numDecompositionsToEncode = 5;\n\n  function getMinMax(frameInfo, pixelData) {\n    const numPixels = frameInfo.width * frameInfo.height * frameInfo.componentCount;\n    let min = pixelData[0];\n    let max = pixelData[0];\n    for(let i=0; i < numPixels; i++) {\n      if(pixelData[i] < min) {\n        min = pixelData[i];\n      }\n      if(pixelData[i] > max) {\n        max = pixelData[i];\n      }\n    }\n    return {min, max};\n  }\n\n  function getPixelData(frameInfo, decodedBuffer) {\n    if(frameInfo.bitsPerSample > 8) {\n      if(frameInfo.isSigned) {\n        return new Int16Array(decodedBuffer.buffer, decodedBuffer.byteOffset, decodedBuffer.byteLength / 2);\n      } else {\n        return new Uint16Array(decodedBuffer.buffer, decodedBuffer.byteOffset, decodedBuffer.byteLength / 2);\n      }\n    } else {\n      return decodedBuffer;\n    }\n  }\n\n  function colorToCanvas(frameInfo, pixelData, imageData) {\n    let outOffset = 0;\n    const bytesPerSample = (frameInfo.bitsPerSample <= 8) ? 1 : 2;\n    let planeSize = frameInfo.width * frameInfo.height * bytesPerSample;\n    let shift = 0;\n    if(frameInfo.bitsPerSample > 8) {\n      shift = 8;\n    }\n    let inOffset = 0;\n   \n    for(var y=0; y < frameInfo.height; y++) {\n      for (var x = 0; x < frameInfo.width; x++) {\n        imageData.data[outOffset++] = pixelData[inOffset++] >> shift;\n        imageData.data[outOffset++] = pixelData[inOffset++] >> shift;\n        imageData.data[outOffset++] = pixelData[inOffset++] >> shift;\n        imageData.data[outOffset++] = 255;\n      }\n    }\n  }\n\n  function grayToCanvas(frameInfo, pixelData, imageData) {\n    var outOffset = 0;\n    var planeSize = frameInfo.width * frameInfo.height;\n    var inOffset = 0;\n   \n    if(!minMax) {\n      minMax = getMinMax(frameInfo, pixelData);\n      $('#minPixel').text('' + minMax.min);\n      $('#maxPixel').text('' + minMax.max);\n    }\n\n    //console.log(minMax);\n    let dynamicRange = minMax.max - minMax.min;\n    $('#dynamicRange').text('' + dynamicRange);\n    //console.log('dynamicRange=', dynamicRange);\n    let bitsOfData = 1;\n    while(dynamicRange > 1) {\n      dynamicRange = dynamicRange >> 1;\n      bitsOfData++;\n    }\n    //console.log('bitsOfData = ', bitsOfData);\n    let bitShift = bitsOfData - 8;\n    const offset = -minMax.min;\n    //console.log('bitShift=', bitShift);\n    //console.log('offset=', offset);\n    \n    for(var y=0; y < frameInfo.height; y++) {\n      for (var x = 0; x < frameInfo.width; x++) {\n        if(frameInfo.bitsPerSample <= 8) {\n          const value = pixelData[inOffset++];\n          imageData.data[outOffset] = value;\n          imageData.data[outOffset + 1] = value;\n          imageData.data[outOffset + 2] = value;\n          imageData.data[outOffset + 3] = 255;\n          outOffset += 4;\n        } \n        else // bitsPerSample > 8 \n        {\n          // Do a simple transformation to display 16 bit data:\n          //  * Offset the pixels so the smallest value is 0\n          //  * Shift the pixels to display the most significant 8 bits\n          const fullPixel = pixelData[inOffset++] + offset;\n          let value = (fullPixel >> bitShift);\n          imageData.data[outOffset] = value;\n          imageData.data[outOffset + 1] = value;\n          imageData.data[outOffset + 2] = value;\n          imageData.data[outOffset + 3] = 255;\n          outOffset += 4;\n        }\n      }\n    }\n  }\n\n  function deltasToCanvas(frameInfo, pixelData, imageData, signed) {\n    if(!uncompressedImageFrame) {\n      return;\n    }\n    const deltas = new Int32Array(frameInfo.height * frameInfo.width);\n    const uif = getPixelData(frameInfo, uncompressedImageFrame, signed);\n    let inOffset = 0;\n    let outOffset = 0;\n    for(var y=0; y < frameInfo.height; y++) {\n      for (var x = 0; x < frameInfo.width; x++) {\n          const unc = uif[inOffset];\n          const comp = pixelData[inOffset];\n          deltas[inOffset++] = Math.abs(comp - unc);\n      }\n    }\n    const deltaMinMax = getMinMax(frameInfo, deltas);\n    console.log('deltas min/max', deltaMinMax);\n    inOffset = 0;\n\n    for(var y=0; y < frameInfo.height; y++) {\n      for (var x = 0; x < frameInfo.width; x++) {\n        if(uncompressedImageFrame) {\n          const delta = deltas[inOffset];\n          inOffset++;\n          imageData.data[outOffset] = delta;\n          imageData.data[outOffset + 1] = delta;\n          imageData.data[outOffset + 2] = delta;\n          imageData.data[outOffset + 3] = 255;\n          outOffset += 4;\n        }\n      } \n    }\n  }\n\n  function display(frameInfo, decodedBuffer, interleaveMode) {\n\n    const pixelData = getPixelData(frameInfo, decodedBuffer);\n\n    const begin = performance.now(); // performance.now() returns value in milliseconds\n    \n    var c = document.getElementById(\"myCanvas\");\n    var ctx = c.getContext(\"2d\");\n\n    c.width = frameInfo.width;\n    c.height = frameInfo.height;\n    var myImageData = ctx.createImageData(frameInfo.width, frameInfo.height);\n\n    const visualizeDeltas = $('#visualizeDeltas').is(\":checked\"); \n\n    if(frameInfo.componentCount > 1) {\n      colorToCanvas(frameInfo, pixelData, myImageData, 2);\n    } else {\n      if(visualizeDeltas) {\n        deltasToCanvas(frameInfo, pixelData, myImageData);\n      } else {\n        grayToCanvas(frameInfo, pixelData, myImageData);\n      }\n    }\n    \n    ctx.putImageData(myImageData, 0, 0);\n    const end = performance.now();\n    $('#displayTime').text((end-begin).toFixed(2) + ' ms');\n  }\n\n  function decode(iterations = 1) {\n    $('#encodedSize').text('' + encodedBitStream.length.toLocaleString() + ' bytes');\n\n    const encodedBufferPtr = dicomrle__WEBPACK_IMPORTED_MODULE_0__[\"get_encoded_buffer\"](encodedBitStream.length);\n    const encodedBuffer = new Uint8Array(dicomrle_dicomrle_wasm_bg__WEBPACK_IMPORTED_MODULE_1__[\"memory\"].buffer, encodedBufferPtr, encodedBitStream.length);\n    // copy RLE encoded image bits into WASM memory\n    encodedBuffer.set(encodedBitStream);\n\n    // Set decoded buffer size\n    const encodedBufferLength = 512 * 512 * 2; // 512kb for CT image\n    const decodedBufferPtr = dicomrle__WEBPACK_IMPORTED_MODULE_0__[\"get_decoded_buffer\"](encodedBufferLength);\n    const decodedBuffer = new Uint8Array(dicomrle_dicomrle_wasm_bg__WEBPACK_IMPORTED_MODULE_1__[\"memory\"].buffer, decodedBufferPtr, encodedBufferLength);\n\n    // Decode\n    const begin = performance.now(); // performance.now() returns value in milliseconds\n    for(let i=0; i < iterations; i++) {\n      dicomrle__WEBPACK_IMPORTED_MODULE_0__[\"decode\"]();\n    }\n    const end = performance.now();\n    $('#decodeTime').text(((end-begin) / iterations).toFixed(2) + ' ms');\n\n    //frameInfo = decoder.getFrameInfo();\n    frameInfo = {\n      width: 512,\n      height: 512,\n      bitsPerSample: 16,\n      isSigned: true,\n      componentCount: 1\n    }\n    // Display image properties\n    $('#status').text('OK');\n    $('#resolution').text(''+frameInfo.width + 'x' + frameInfo.height);\n    $('#pixelFormat').text(''+frameInfo.bitsPerSample +' bpp ' + (frameInfo.isSigned ? 'signed' : 'unsigned'));\n    $('#componentCount').text(''+frameInfo.componentCount);\n\n    //$('#colorTransform').text('' + decoder.getColorSpace());\n\n    // Display Image\n    //var decodedBuffer = decoder.getDecodedBuffer();\n    //console.log('decodedBuffer=', decodedBuffer);\n\n    $('#decodedSize').text(''+decodedBuffer.length.toLocaleString() + \" bytes\");\n    $('#compressionRatio').text('' + (decodedBuffer.length /encodedBitStream.length).toFixed(2) + \":1\");\n   \n    display(frameInfo, decodedBuffer, 2);\n    //frameInfo = decoder.getFrameInfo();\n  }\n\n  function encode(iterations = 1) {\n    // Setup buffer\n    const decodedBytes = encoder.getDecodedBuffer(frameInfo);\n    decodedBytes.set(uncompressedImageFrame);\n    const progressive = $('#progressive').is(\":checked\"); \n\n    encoder.setProgressive(progressive);\n    encoder.setQuality(compressionRatio);\n\n    // Do the encode\n    const begin = performance.now(); // performance.now() returns value in milliseconds\n    for(let i=0; i < iterations; i++) {\n      encoder.encode();\n    }\n    const end = performance.now();\n    $('#encodeTime').text(((end-begin) / iterations).toFixed(2) + ' ms');\n  }\n\n  function loadArrayBuffer(arrayBuffer) {\n    try {\n      fullEncodedBitStream = new Uint8Array(arrayBuffer);\n      const numBytes = 0;// 122003;\n      encodedBitStream = new Uint8Array(arrayBuffer, 0, fullEncodedBitStream.length -numBytes);\n      //encodedBitStream = new Uint8Array(arrayBuffer);\n      $('#encodedBytesRead').text('' + encodedBitStream.length.toLocaleString() + ' / ' + fullEncodedBitStream.length.toLocaleString() + ' bytes ');\n      $('#encodedBytesReadRange').attr('max', encodedBitStream.length-1);\n      //$('#encodedBytesReadRange').attr('max', 512);\n      decode();\n      //uncompressedImageFrame = new Uint8Array(decoder.getDecodedBuffer().length);\n      //uncompressedImageFrame.set(decoder.getDecodedBuffer());\n    }\n    catch(ex) {\n      $('#status').text('Exception thrown while parsing ' + ex);\n    }\n  }\n\n  function load(url) {\n    fetch(url)\n    .then((response) => {\n      return response.arrayBuffer();\n    })\n    .then((arrayBuffer) => {\n      loadArrayBuffer(arrayBuffer);\n    }).catch(function() {\n      $('#status').text('error loading ' + url);\n    });\n  }\n\n  function reset() {\n    decodeLevel = 0;\n    minMax = undefined;\n    const c = document.getElementById(\"myCanvas\");\n    const ctx = c.getContext(\"2d\");\n    ctx.fillRect(0,0,c.width, c.height);\n    $('#status').text('OK');\n\n    $('#encodeTime').text('');\n    $('#decodeTime').text('');\n    $('#displayTime').text('');\n\n    $('#encodedSize').text('');\n    $('#decodedSize').text('');\n    $('#compressionRatio').text('');\n\n    $('#resolution').text('');\n    $('#pixelFormat').text('');\n    $('#componentCount').text('');\n    \n    $('#reversible').text('');\n    $('#numDecompositions').text('');\n    $('#progessionOrder').text('');\n}\n\n  function init(path) {\n    $('#imageSelector').val(path);\n    load(path);\n  }\n\n \n\n  function main() {\n\n    init('https://chafey.github.io/dicomrle-rs/tests/rleimage/ct.rle');\n\n    $('#imageSelector').change(function(e) {\n      reset();\n      load(e.target.options[e.target.selectedIndex].value);\n    });\n\n    $('#visualizeDeltas').change(function() {\n      // this will contain a reference to the checkbox   \n      if (this.checked) {\n        decode();\n      } else {\n        decode();\n      }\n    });\n\n    $('#useWASM').change(function() {\n      if (this.checked) {\n        encoder = encoderwasm;\n        decoder = decoderwasm;\n        decode();\n      } else {\n        encoder = encoderjs;\n        decoder = decoderjs;\n        decode();\n      }\n    });\n\n    $('#decodeLayerRange').on('input', function(e) {\n      decodeLayer = parseInt($(this).val());\n      $('#decodeLayer').text('' + decodeLayer);\n      decode();\n    });\n\n    $('#decodeLevelRange').on('input', function(e) {\n      decodeLevel = parseInt($(this).val());\n      const resolutionAtLevel = decoder.calculateSizeAtDecompositionLevel(decodeLevel);\n      $('#decodeLevel').text('' + decodeLevel + ' (' + resolutionAtLevel.width + 'x' + resolutionAtLevel.height + ')');\n      decode();\n    });\n\n    $('#progressionOrderSelector').change(function(e) {\n      progressionOrder = parseInt(e.target.options[e.target.selectedIndex].value);\n      encode();\n       // Get the encoded bytes and display them\n      const encodedBytes = encoder.getEncodedBuffer();\n      encodedBitStream = encodedBytes;\n      decode();\n    });\n\n    $('#decompositionsSelector').change(function(e) {\n      numDecompositionsToEncode = parseInt(e.target.options[e.target.selectedIndex].value);\n      encode();\n       // Get the encoded bytes and display them\n      const encodedBytes = encoder.getEncodedBuffer();\n      encodedBitStream = encodedBytes;\n      decode();\n    });\n\n    $('#benchmark').click(function(e) {\n      $('#status').text('Please wait while benchmark runs....');\n      setTimeout(() => {\n        const iterations = 5;\n        decode(iterations)\n        encode(iterations)\n        $('#status').text('OK - ' + iterations + ' iterations encode/decode');\n      }, 1);\n    });\n\n    $('#encodedBytesReadRange').on('input', function(e) {\n      const numBytes = parseInt($(this).val());\n      let length = fullEncodedBitStream.length - numBytes;\n      encodedBitStream = new Uint8Array(length);\n      for(let i=0; i < length; i++) {\n        encodedBitStream[i] = fullEncodedBitStream[i];\n      }\n      $('#encodedBytesRead').text('' + encodedBitStream.length.toLocaleString() + ' / ' + fullEncodedBitStream.length.toLocaleString() + ' bytes ');\n      try {\n        decode();\n      } catch(ex) {\n        console.log(ex);\n      } finally {\n      }\n    });\n\n\n    $('#bytesDecodedRange').on('input', function(e) {\n      bytePercent = parseFloat($(this).val());\n      console.log('bytePercent =', bytePercent);\n      const numBytes = Math.floor(encodedBitStream.length * bytePercent / 100);\n      console.log('numBytes=', numBytes);\n      const fullEncodedBitStream = encodedBitStream.slice(0, numBytes);\n      //encodedBitStream = new Uint8Array(numBytes);\n      //encodedBitStream.set(fullEncodedBitStream);\n      console.log(encodedBitStream.length);\n      $('#bytesDecoded').text('' + bytePercent + \"% (\" + numBytes + \" bytes)\");\n      decode();\n      encodedBitStream = fullEncodedBitStream;\n    });\n\n    $('#targetCompressionRatioRange').on('input', function(e) {\n      compressionRatio = 100.0 - parseFloat($(this).val());\n      $('#targetCompressionRatio').text('' + compressionRatio.toFixed(2));\n      encode();\n       // Get the encoded bytes and display them\n      const encodedBytes = encoder.getEncodedBuffer();\n      encodedBitStream = encodedBytes;\n      decode();\n    });\n\n    // this function gets called once the user drops the file onto the div\n    function handleFileSelect(evt) {\n      evt.stopPropagation();\n      evt.preventDefault();\n\n      // Get the FileList object that contains the list of files that were dropped\n      var files = evt.dataTransfer.files;\n\n      // this UI is only built for a single file so just dump the first one\n      var file = files[0];\n\n      const fileReader = new FileReader();\n      fileReader.onload = function (e) {\n        const fileAsArrayBuffer = e.target.result;\n        loadArrayBuffer(fileAsArrayBuffer);\n      };\n      fileReader.readAsArrayBuffer(file);\n    }\n\n    function handleDragOver(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n        evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.\n    }\n\n    // Setup the dnd listeners.\n    var dropZone = document.getElementById('myCanvas');\n    dropZone.addEventListener('dragover', handleDragOver, false);\n    dropZone.addEventListener('drop', handleFileSelect, false);\n  }\n\n  $('#download').click(function() {\n    // download the de-identified DICOM P10 bytestream\n    var blob = new Blob([encodedBitStream], {type: \"image/j2c\"});\n    var url = window.URL.createObjectURL(blob);\n    window.open(url);\n    window.URL.revokeObjectURL(url);\n  });\n\n  main();\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ })

}]);